"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[2443],{48193:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>o});var s=i(30758);const r={},l=s.createContext(r);function t(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(l.Provider,{value:n},e.children)}},81096:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"architecture","title":"Architecture","description":"This document provides a comprehensive overview of Dkron\'s architecture, internal components, and how they work together to provide a distributed, fault-tolerant job scheduling system.","source":"@site/docs/architecture.md","sourceDirName":".","slug":"/architecture","permalink":"/docs/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/distribworks/dkron/tree/main/website/docs/docs/architecture.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Intro","permalink":"/docs/intro"},"next":{"title":"Job chaining","permalink":"/docs/usage/chaining"}}');var r=i(86070),l=i(48193);const t={sidebar_position:2},o="Architecture",d={},c=[{value:"System Architecture",id:"system-architecture",level:2},{value:"Key Components",id:"key-components",level:2},{value:"Dkron Scheduling Flow",id:"dkron-scheduling-flow",level:2},{value:"Job Execution Flow",id:"job-execution-flow",level:2},{value:"Component Details",id:"component-details",level:2},{value:"Agent Server",id:"agent-server",level:3},{value:"Leader Server (Raft Leader)",id:"leader-server-raft-leader",level:3},{value:"Worker Agent",id:"worker-agent",level:3},{value:"Storage Layer",id:"storage-layer",level:3},{value:"Executor Plugins",id:"executor-plugins",level:3},{value:"Communication Protocols",id:"communication-protocols",level:3},{value:"Leadership and Fault Tolerance",id:"leadership-and-fault-tolerance",level:2},{value:"Leader Responsibilities",id:"leader-responsibilities",level:3},{value:"Fault Tolerance",id:"fault-tolerance",level:3},{value:"Consensus and Replication",id:"consensus-and-replication",level:2},{value:"How Raft Works in Dkron",id:"how-raft-works-in-dkron",level:3},{value:"What Gets Replicated",id:"what-gets-replicated",level:3},{value:"Quorum Requirements",id:"quorum-requirements",level:3},{value:"Cluster Membership with Serf",id:"cluster-membership-with-serf",level:2},{value:"Serf Responsibilities",id:"serf-responsibilities",level:3},{value:"Gossip Protocol Benefits",id:"gossip-protocol-benefits",level:3},{value:"Data Storage",id:"data-storage",level:2},{value:"BuntDB (Application Data)",id:"buntdb-application-data",level:3},{value:"BoltDB (Raft Log)",id:"boltdb-raft-log",level:3},{value:"Plugin System",id:"plugin-system",level:2},{value:"Plugin Types",id:"plugin-types",level:3},{value:"Plugin Communication",id:"plugin-communication",level:3},{value:"Network Ports",id:"network-ports",level:2},{value:"Scalability Considerations",id:"scalability-considerations",level:2},{value:"Horizontal Scaling",id:"horizontal-scaling",level:3},{value:"Vertical Scaling",id:"vertical-scaling",level:3},{value:"Performance Limits",id:"performance-limits",level:3},{value:"Security Architecture",id:"security-architecture",level:2},{value:"Network Security",id:"network-security",level:3},{value:"Access Control",id:"access-control",level:3},{value:"Data Security",id:"data-security",level:3},{value:"High Availability Setup",id:"high-availability-setup",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Design Philosophy",id:"design-philosophy",level:2},{value:"Design Principles",id:"design-principles",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,r.jsx)(n.p,{children:"This document provides a comprehensive overview of Dkron's architecture, internal components, and how they work together to provide a distributed, fault-tolerant job scheduling system."}),"\n",(0,r.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Dkron utilizes a server-agent architecture where multiple agents can form a cluster for high availability. Here's a high-level overview of how Dkron works:"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    Node1["Dkron Server Node 1<br/>(Leader)"] <--\x3e Node2["Dkron Server Node 2<br/>(Follower)"]\n    Node1 <--\x3e Node3["Dkron Server Node 3<br/>(Follower)"]\n    Node1 <--\x3e Node4["Dkron Server Node 4<br/>(Follower)"]\n    Node2 <--\x3e Node3\n    Node2 <--\x3e Node4\n    Node3 <--\x3e Node4'}),"\n",(0,r.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,r.jsx)(n.p,{children:"Dkron's architecture consists of several key components:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Server Nodes"}),": Nodes running in server mode (with ",(0,r.jsx)(n.code,{children:"--server"})," flag) that participate in leader election and can schedule jobs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Leader Node"}),": One server node is elected as leader and is responsible for:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scheduling jobs"}),"\n",(0,r.jsx)(n.li,{children:"Assigning job executions to target nodes"}),"\n",(0,r.jsx)(n.li,{children:"Maintaining the cluster state"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Follower Nodes"}),": Server nodes that are not the leader. They:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can execute jobs when selected as targets"}),"\n",(0,r.jsx)(n.li,{children:"Are ready to become the leader if the current leader fails"}),"\n",(0,r.jsx)(n.li,{children:"Maintain a replicated log of all operations"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Embedded Data Store"}),": Dkron uses dual embedded databases:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BuntDB"})," for application data (job definitions, execution history)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BoltDB"})," for Raft consensus log (operation replication)"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Serf Layer"}),": Handles cluster membership, failure detection, and messaging between nodes using the gossip protocol."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"HTTP API and Web UI"}),": Provides a RESTful API and web interface for job management."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executors"}),": Plugins that handle the actual execution of job commands (shell, HTTP, etc.)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Processors"}),": Plugins that process the output of job executions (log, file, email, etc.)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dkron-scheduling-flow",children:"Dkron Scheduling Flow"}),"\n",(0,r.jsx)(n.p,{children:"Here's how job scheduling works in Dkron:"}),"\n",(0,r.jsx)(n.mermaid,{value:"flowchart LR\n    A[Job Definition] --\x3e B[Leader Scheduling]\n    B --\x3e C[Target Selection]\n    C --\x3e D[Execution]\n    D --\x3e E[Processing Output]\n    E --\x3e F[Results Storage]"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Job Definition"}),": Users define jobs with scheduling parameters (cron expression), execution options, and target node tags."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leader Scheduling"}),": The leader node tracks job schedules and triggers executions at the appropriate times."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Target Selection"}),": The leader selects target nodes for job execution based on tags and execution options."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution"}),": Target nodes run the job using the specified executor."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Processing Output"}),": Job output is processed by configured processors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Results Storage"}),": Execution results are stored in the distributed data store."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"job-execution-flow",children:"Job Execution Flow"}),"\n",(0,r.jsx)(n.p,{children:"This diagram illustrates the detailed function call flow when a job is executed in Dkron. It shows the interaction between three main components: the Agent Server (which receives requests), the Leader Server (which orchestrates scheduling), and the Worker Agent (which executes jobs)."}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client as Client/Scheduler\n    participant AS as Agent Server\n    participant Leader as Leader Server<br/>(Raft Leader)\n    participant Store as Storage<br/>(BuntDB)\n    participant Worker as Worker Agent\n    participant Executor as Executor Plugin\n    \n    Note over Client,Executor: Job Execution Request Flow\n    \n    %% Request arrives\n    Client->>AS: HTTP Request<br/>jobRunHandler()\n    AS->>Leader: (grpcc) RunJob()<br/>via gRPC\n    \n    %% Leader processing\n    Leader->>Leader: (grpcs) RunJob()\n    Note over Leader: Verify leadership\n    Leader->>Leader: (a *Agent) Run()\n    \n    Leader->>Store: (a.Store) GetJob()\n    Store--\x3e>Leader: Job details\n    \n    Leader->>Leader: (a *Agent) getTargetNodes()\n    Note over Leader: Select nodes based on<br/>job tags & node tags\n    \n    %% Execution on worker\n    Leader->>Worker: (grpcc) AgentRun()<br/>via gRPC streaming\n    \n    activate Worker\n    Worker->>Worker: (as *AgentServer) AgentRun()\n    Worker->>Leader: Stream: Initial execution state\n    \n    Worker->>Executor: executor.Execute()\n    Note over Executor: Execute job via plugin<br/>(shell, http, kafka, etc)\n    \n    activate Executor\n    Executor->>Worker: Stream output via<br/>statusAgentHelper\n    Executor--\x3e>Worker: Execution result\n    deactivate Executor\n    \n    Worker->>Leader: Stream: Final execution result\n    deactivate Worker\n    \n    %% Completion and storage\n    Leader->>Leader: (grpcs) ExecutionDone()\n    Leader->>Leader: grpcs.agent.raft.Apply()\n    Note over Leader: Apply to Raft log\n    \n    Leader->>Store: Store execution result\n    Leader--\x3e>Client: Response"}),"\n",(0,r.jsx)(n.h2,{id:"component-details",children:"Component Details"}),"\n",(0,r.jsx)(n.h3,{id:"agent-server",children:"Agent Server"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Entry point for HTTP/gRPC requests"}),"\n",(0,r.jsx)(n.li,{children:"Routes job execution requests to the leader"}),"\n",(0,r.jsx)(n.li,{children:"Can forward requests if not the leader"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"leader-server-raft-leader",children:"Leader Server (Raft Leader)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Elected via Raft consensus protocol"}),"\n",(0,r.jsxs)(n.li,{children:["Orchestrates all job scheduling via the ",(0,r.jsx)(n.code,{children:"Scheduler"})]}),"\n",(0,r.jsx)(n.li,{children:"Selects target nodes based on job tags"}),"\n",(0,r.jsx)(n.li,{children:"Coordinates execution across worker nodes"}),"\n",(0,r.jsx)(n.li,{children:"Applies state changes to Raft log for consistency"}),"\n",(0,r.jsx)(n.li,{children:"Stores execution results in BuntDB"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"worker-agent",children:"Worker Agent"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Executes jobs assigned by the leader"}),"\n",(0,r.jsx)(n.li,{children:"Streams execution progress back to leader in real-time"}),"\n",(0,r.jsx)(n.li,{children:"Can be any node in the cluster (including the leader)"}),"\n",(0,r.jsx)(n.li,{children:"Uses executor plugins for actual job execution"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"storage-layer",children:"Storage Layer"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BuntDB"}),": Embedded key-value store for application data (jobs, executions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"BoltDB"}),": Raft log storage for consensus and replication"]}),"\n",(0,r.jsx)(n.li,{children:"Application data is replicated across all server nodes via Raft"}),"\n",(0,r.jsx)(n.li,{children:"Fast, embedded storage with no external dependencies"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"executor-plugins",children:"Executor Plugins"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Pluggable execution backends (shell, HTTP, Kafka, NATS, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Implement the actual job execution logic"}),"\n",(0,r.jsx)(n.li,{children:"Stream output back to the worker agent during execution"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HTTP/REST API"})," for external clients"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"gRPC"})," with bidirectional streaming for inter-node communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serf"})," for cluster membership and failure detection"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Raft"})," for consensus and state replication"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"leadership-and-fault-tolerance",children:"Leadership and Fault Tolerance"}),"\n",(0,r.jsx)(n.p,{children:"Dkron uses a leader-follower model for high availability:"}),"\n",(0,r.jsx)(n.h3,{id:"leader-responsibilities",children:"Leader Responsibilities"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Monitors leadership status through ",(0,r.jsx)(n.code,{children:"monitorLeadership()"})]}),"\n",(0,r.jsxs)(n.li,{children:["When elected, calls ",(0,r.jsx)(n.code,{children:"establishLeadership()"})," to initialize duties"]}),"\n",(0,r.jsxs)(n.li,{children:["Starts the ",(0,r.jsx)(n.code,{children:"Scheduler"})," to begin scheduling jobs"]}),"\n",(0,r.jsx)(n.li,{children:"Reconciles cluster members via Serf"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"fault-tolerance",children:"Fault Tolerance"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the leader fails, Raft automatically elects a new leader from follower nodes"}),"\n",(0,r.jsx)(n.li,{children:"The new leader takes over scheduling without job loss"}),"\n",(0,r.jsx)(n.li,{children:"Running jobs continue to completion on their worker nodes"}),"\n",(0,r.jsx)(n.li,{children:"Serf detects the failure and updates cluster membership"}),"\n",(0,r.jsx)(n.li,{children:"State is preserved through Raft's replicated log"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consensus-and-replication",children:"Consensus and Replication"}),"\n",(0,r.jsxs)(n.p,{children:["Dkron uses the ",(0,r.jsx)(n.strong,{children:"Raft consensus algorithm"})," (via HashiCorp Raft library) to ensure data consistency across the cluster:"]}),"\n",(0,r.jsx)(n.h3,{id:"how-raft-works-in-dkron",children:"How Raft Works in Dkron"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leader Election"}),": Nodes vote to elect a leader. The leader handles all writes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Log Replication"}),": The leader replicates all state changes to follower nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Commitment"}),": Changes are committed only when a majority of nodes have replicated them."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety"}),": Once committed, changes are durable and will survive failures."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"what-gets-replicated",children:"What Gets Replicated"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Job definitions (create, update, delete)"}),"\n",(0,r.jsx)(n.li,{children:"Job execution results"}),"\n",(0,r.jsx)(n.li,{children:"Configuration changes"}),"\n",(0,r.jsx)(n.li,{children:"System state"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"quorum-requirements",children:"Quorum Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Minimum 3 server nodes recommended for production (allows 1 failure)"}),"\n",(0,r.jsx)(n.li,{children:"5 server nodes allow 2 failures"}),"\n",(0,r.jsx)(n.li,{children:"Quorum = (N/2) + 1 where N is the number of servers"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"cluster-membership-with-serf",children:"Cluster Membership with Serf"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Serf"})," provides cluster membership and failure detection through a gossip protocol:"]}),"\n",(0,r.jsx)(n.h3,{id:"serf-responsibilities",children:"Serf Responsibilities"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Membership"}),": Track which nodes are part of the cluster"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failure Detection"}),": Quickly detect when nodes fail or become unreachable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event Propagation"}),": Broadcast custom events across the cluster"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Metadata"}),": Share node information (tags, roles, etc.)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"gossip-protocol-benefits",children:"Gossip Protocol Benefits"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Scales to thousands of nodes efficiently"}),"\n",(0,r.jsx)(n.li,{children:"Eventually consistent membership information"}),"\n",(0,r.jsx)(n.li,{children:"Low network overhead"}),"\n",(0,r.jsx)(n.li,{children:"Fast failure detection (typically within seconds)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-storage",children:"Data Storage"}),"\n",(0,r.jsx)(n.h3,{id:"buntdb-application-data",children:"BuntDB (Application Data)"}),"\n",(0,r.jsx)(n.p,{children:"Dkron uses BuntDB as the primary application data store:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Key-Value Store"}),": Simple, fast embedded database"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ACID Transactions"}),": Ensures data consistency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Indexes"}),": Fast lookups for jobs and executions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Storage Limits"}),": Keeps last 100 executions per job"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"File-Based"}),": Data stored in a single file (",(0,r.jsx)(n.code,{children:"dkron.db"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"boltdb-raft-log",children:"BoltDB (Raft Log)"}),"\n",(0,r.jsx)(n.p,{children:"Raft operations are stored in BoltDB:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Append-Only Log"}),": Records all state changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Snapshots"}),": Periodic snapshots to reduce log size"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Replication"}),": Log entries are replicated to all servers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Recovery"}),": Allows nodes to catch up after downtime"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"plugin-system",children:"Plugin System"}),"\n",(0,r.jsxs)(n.p,{children:["Dkron uses ",(0,r.jsx)(n.strong,{children:"HashiCorp's go-plugin"})," framework for a flexible plugin architecture:"]}),"\n",(0,r.jsx)(n.h3,{id:"plugin-types",children:"Plugin Types"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Executors"}),": Define how jobs are executed"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Built-in: shell, http, grpc, kafka, nats, rabbitmq, gcppubsub"}),"\n",(0,r.jsx)(n.li,{children:"Custom: Users can write their own executors"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Processors"}),": Define how job output is processed"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Built-in: log, files, syslog, fluent"}),"\n",(0,r.jsx)(n.li,{children:"Custom: Users can write their own processors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"plugin-communication",children:"Plugin Communication"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Plugins run as separate processes"}),"\n",(0,r.jsx)(n.li,{children:"Communication via gRPC"}),"\n",(0,r.jsx)(n.li,{children:"Language-agnostic (can be written in any language with gRPC support)"}),"\n",(0,r.jsx)(n.li,{children:"Isolated from main process (plugin crashes don't affect Dkron)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"network-ports",children:"Network Ports"}),"\n",(0,r.jsx)(n.p,{children:"Default ports used by Dkron:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Port"}),(0,r.jsx)(n.th,{children:"Protocol"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"8080"}),(0,r.jsx)(n.td,{children:"HTTP"}),(0,r.jsx)(n.td,{children:"REST API and Web UI"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"8946"}),(0,r.jsx)(n.td,{children:"TCP/UDP"}),(0,r.jsx)(n.td,{children:"Serf gossip protocol"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"8190"}),(0,r.jsx)(n.td,{children:"TCP"}),(0,r.jsx)(n.td,{children:"Raft consensus"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"6868"}),(0,r.jsx)(n.td,{children:"gRPC"}),(0,r.jsx)(n.td,{children:"Inter-node communication"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"scalability-considerations",children:"Scalability Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"horizontal-scaling",children:"Horizontal Scaling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Server Nodes"}),": 3-5 servers recommended for most deployments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Agent Nodes"}),": Can scale to hundreds or thousands of nodes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Job Distribution"}),": Use tags to distribute load across agents"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"vertical-scaling",children:"Vertical Scaling"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leader Node"}),": May need more resources as job count increases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Memory"}),": Increases with number of jobs and execution history"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CPU"}),": Leader uses CPU for scheduling; agents use CPU for execution"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance-limits",children:"Performance Limits"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Jobs"}),": Can handle thousands of job definitions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Frequency"}),": Avoid sub-second schedules for many jobs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cluster Size"}),": Tested with hundreds of nodes (agent nodes)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent Executions"}),": Limited by agent resources, not Dkron itself"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"security-architecture",children:"Security Architecture"}),"\n",(0,r.jsx)(n.h3,{id:"network-security",children:"Network Security"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"TLS support for HTTP API"}),"\n",(0,r.jsx)(n.li,{children:"Encryption for Serf gossip traffic"}),"\n",(0,r.jsx)(n.li,{children:"Raft communication can be secured with TLS"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"access-control",children:"Access Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Basic authentication for HTTP API"}),"\n",(0,r.jsx)(n.li,{children:"ACL system available in Pro version"}),"\n",(0,r.jsx)(n.li,{children:"API token support"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"data-security",children:"Data Security"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Encryption at rest (optional, filesystem-level)"}),"\n",(0,r.jsx)(n.li,{children:"Encryption in transit (TLS)"}),"\n",(0,r.jsx)(n.li,{children:"Secret management through environment variables or external systems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"high-availability-setup",children:"High Availability Setup"}),"\n",(0,r.jsx)(n.p,{children:"Recommended HA configuration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Load Balancer (Optional)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502              \u2502              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502 Server 1 \u2502   \u2502 Server 2 \u2502   \u2502 Server 3 \u2502\n    \u2502 (Leader) \u2502   \u2502(Follower)\u2502   \u2502(Follower)\u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502              \u2502              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502         Serf Gossip Network            \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502              \u2502              \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n    \u2502Agent 1 \u2502   \u2502 Agent 2  \u2502   \u2502 Agent 3  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Deploy servers across multiple availability zones"}),"\n",(0,r.jsx)(n.li,{children:"Use odd number of servers (3 or 5)"}),"\n",(0,r.jsx)(n.li,{children:"Monitor leader election events"}),"\n",(0,r.jsx)(n.li,{children:"Set up proper backup procedures"}),"\n",(0,r.jsx)(n.li,{children:"Use health checks and alerting"}),"\n",(0,r.jsx)(n.li,{children:"Plan for disaster recovery"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"design-philosophy",children:"Design Philosophy"}),"\n",(0,r.jsx)(n.p,{children:"Dkron is designed to solve one problem well: executing commands at given intervals. Following the Unix philosophy of doing one thing and doing it well (like the battle-tested cron), but with the addition of being designed for the cloud era, removing single points of failure in environments where scheduled jobs need to be run across multiple servers."}),"\n",(0,r.jsx)(n.h3,{id:"design-principles",children:"Design Principles"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplicity"}),": Easy to deploy and operate"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reliability"}),": No single points of failure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Handle thousands of nodes and jobs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Observability"}),": Built-in metrics and logging"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extensibility"}),": Plugin system for custom functionality"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);