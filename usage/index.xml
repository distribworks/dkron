<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Usage on Dkron - Distributed job scheduling system</title>
    <link>/usage/</link>
    <description>Recent content in Usage on Dkron - Distributed job scheduling system</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/usage/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Target nodes spec</title>
      <link>/usage/target-nodes-spec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/target-nodes-spec/</guid>
      <description>Target nodes spec You can choose whether a job is run on a node or nodes by specifying tags and a count of target nodes having this tag do you want a job to run.
The target node syntax: [tag-value]:[count]
 Examples: Target all nodes with a tag:
{ &amp;#34;name&amp;#34;: &amp;#34;job_name&amp;#34;, &amp;#34;command&amp;#34;: &amp;#34;/bin/true&amp;#34;, &amp;#34;schedule&amp;#34;: &amp;#34;@every 2m&amp;#34;, &amp;#34;tags&amp;#34;: { &amp;#34;role&amp;#34;: &amp;#34;web&amp;#34; } } mermaid.initialize({startOnLoad:true}); graph LR; J(&#34;Job tags: #quot;role#quot;: #quot;web#quot;&#34;) --|Run Job|N1[&#34;</description>
    </item>
    
    <item>
      <title>Cron spec</title>
      <link>/usage/cron-spec/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/cron-spec/</guid>
      <description>CRON Expression Format A cron expression represents a set of times, using 6 space-separated fields.
Field name | Mandatory? | Allowed values | Allowed special characters ---------- | ---------- | -------------- | -------------------------- Seconds | Yes | 0-59 | * / , - Minutes | Yes | 0-59 | * / , - Hours | Yes | 0-23 | * / , - Day of month | Yes | 1-31 | * / , - ?</description>
    </item>
    
    <item>
      <title>Clustering</title>
      <link>/usage/clustering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/clustering/</guid>
      <description>Configure a cluster Dkron can run in HA mode, avoiding SPOFs, this mode provides better scalability and better reliability for users that wants a high level of confidence in the cron jobs they need to run.
To form a cluster, server nodes need to know the address of its peers as in the following example:
# dkron.yml join: - 10.19.3.9 - 10.19.4.64 - 10.19.7.215 Etcd For a more in detail guide of clustering with etcd follow this guide: https://github.</description>
    </item>
    
    <item>
      <title>Concurrency</title>
      <link>/usage/concurrency/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/concurrency/</guid>
      <description> Concurrency Jobs can be configured to allow overlapping executions or forbid them.
Concurrency property accepts two option:
 allow (default): Allow concurrent job executions. forbid: If the job is already running don&amp;rsquo;t send the execution, it will skip the executions until the next schedule.  Example:
{ &amp;#34;name&amp;#34;: &amp;#34;job1&amp;#34;, &amp;#34;schedule&amp;#34;: &amp;#34;@every 10s&amp;#34;, &amp;#34;executor&amp;#34;: &amp;#34;shell&amp;#34;, &amp;#34;executor_config&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;echo \&amp;#34;Hello from parent\&amp;#34;&amp;#34; }, &amp;#34;concurrency&amp;#34;: &amp;#34;forbid&amp;#34; }</description>
    </item>
    
    <item>
      <title>Internals</title>
      <link>/usage/internals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/internals/</guid>
      <description>This document is a WIP, it&amp;rsquo;s intended to describe the reasons that lead to design decisions in Dkron.
Execution results Dkron store the result of each job execution in each node.
Every time dkron executes a job it assigns it an execution group, generating a new uuid and send a serf query to target machines and waits for a response.
Each target machine that will run the job, then responds with an execution object saying it started to run the job.</description>
    </item>
    
    <item>
      <title>Job chaining</title>
      <link>/usage/chaining/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/chaining/</guid>
      <description>Job chaining You can set some jobs to run after other job is executed. To setup a job that will be executed after any other given job, just set the parent_job property when saving the new job.
The dependent job will be executed after the main job finished a successful execution.
Child jobs schedule property will be ignored if it&amp;rsquo;s present.
Take into account that parent jobs must be created before any child job.</description>
    </item>
    
    <item>
      <title>Job retries</title>
      <link>/usage/retries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/retries/</guid>
      <description>Jobs can be configured to retry in case of failure.
Configuration { &amp;#34;name&amp;#34;: &amp;#34;job1&amp;#34;, &amp;#34;schedule&amp;#34;: &amp;#34;@every 10s&amp;#34;, &amp;#34;executor&amp;#34;: &amp;#34;shell&amp;#34;, &amp;#34;executor_config&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;echo \&amp;#34;Hello from parent\&amp;#34;&amp;#34; }, &amp;#34;retries&amp;#34;: 5 } In case of failure to run the job in one node, it will try to run the job again in that node until the retries count reaches the limit.</description>
    </item>
    
    <item>
      <title>Metrics</title>
      <link>/usage/metrics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/metrics/</guid>
      <description>Dkron has the ability to send metrics to Statsd for dashboards and historical reporting. It sends job processing metrics and golang, serf metrics too.
Configuration Add this in your yaml config file
dog_statsd_addr: &amp;#34;localhost:8125&amp;#34; Metrics  dkron.agent.event_received.query_execution_done dkron.agent.event_received.query_run_job dkron.memberlist.gossip dkron.memberlist.probeNode dkron.memberlist.pushPullNode dkron.memberlist.tcp.accept dkron.memberlist.tcp.connect dkron.memberlist.tcp.sent dkron.memberlist.udp.received dkron.memberlist.udp.sent dkron.grpc.call_execution_done dkron.grpc.call_get_job dkron.grpc.execution_done dkron.grpc.get_job dkron.runtime.alloc_bytes dkron.runtime.free_count dkron.runtime.gc_pause_ns dkron.runtime.heap_objects dkron.runtime.malloc_count dkron.runtime.num_goroutines dkron.runtime.sys_bytes dkron.runtime.total_gc_pause_ns dkron.runtime.total_gc_runs dkron.serf.coordinate.adjustment_ms dkron.serf.msgs.received dkron.serf.msgs.sent dkron.serf.queries dkron.serf.queries.execution_done dkron.serf.queries.run_job dkron.serf.query_acks dkron.serf.query_responses dkron.serf.queue.Event dkron.serf.queue.Intent dkron.</description>
    </item>
    
    <item>
      <title>Use with AWS ECS</title>
      <link>/usage/ecs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/usage/ecs/</guid>
      <description>Dkron Pro comes with a native ECS executor out of the box.
 Use with Amazon ECS To use Dkron to schedule jobs that run in containers, a wrapper ECS script is needed.
Install the following snippet in the node that will run the call to ECS
 Prerequisites The node that will run the call to ECS will need to have installed
 AWS cli jq  Example ecs-run --cluster cron --task-definition cron-taskdef --container-name cron --region us-east-1 --command &amp;quot;rake foo&amp;quot;</description>
    </item>
    
  </channel>
</rss>